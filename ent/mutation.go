// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/BradHacker/titan/ent/action"
	"github.com/BradHacker/titan/ent/agent"
	"github.com/BradHacker/titan/ent/beacon"
	"github.com/BradHacker/titan/ent/instruction"
	"github.com/BradHacker/titan/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAction      = "Action"
	TypeAgent       = "Agent"
	TypeBeacon      = "Beacon"
	TypeInstruction = "Instruction"
)

// ActionMutation represents an operation that mutates the Action nodes in the graph.
type ActionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	actionType         *action.ActionType
	cmd                *string
	args               *[]string
	output             *string
	clearedFields      map[string]struct{}
	instruction        *int
	clearedinstruction bool
	done               bool
	oldValue           func(context.Context) (*Action, error)
	predicates         []predicate.Action
}

var _ ent.Mutation = (*ActionMutation)(nil)

// actionOption allows management of the mutation configuration using functional options.
type actionOption func(*ActionMutation)

// newActionMutation creates new mutation for the Action entity.
func newActionMutation(c config, op Op, opts ...actionOption) *ActionMutation {
	m := &ActionMutation{
		config:        c,
		op:            op,
		typ:           TypeAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionID sets the ID field of the mutation.
func withActionID(id int) actionOption {
	return func(m *ActionMutation) {
		var (
			err   error
			once  sync.Once
			value *Action
		)
		m.oldValue = func(ctx context.Context) (*Action, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Action.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAction sets the old Action of the mutation.
func withAction(node *Action) actionOption {
	return func(m *ActionMutation) {
		m.oldValue = func(context.Context) (*Action, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetActionType sets the "actionType" field.
func (m *ActionMutation) SetActionType(at action.ActionType) {
	m.actionType = &at
}

// ActionType returns the value of the "actionType" field in the mutation.
func (m *ActionMutation) ActionType() (r action.ActionType, exists bool) {
	v := m.actionType
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "actionType" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldActionType(ctx context.Context) (v action.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ResetActionType resets all changes to the "actionType" field.
func (m *ActionMutation) ResetActionType() {
	m.actionType = nil
}

// SetCmd sets the "cmd" field.
func (m *ActionMutation) SetCmd(s string) {
	m.cmd = &s
}

// Cmd returns the value of the "cmd" field in the mutation.
func (m *ActionMutation) Cmd() (r string, exists bool) {
	v := m.cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldCmd returns the old "cmd" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldCmd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmd: %w", err)
	}
	return oldValue.Cmd, nil
}

// ResetCmd resets all changes to the "cmd" field.
func (m *ActionMutation) ResetCmd() {
	m.cmd = nil
}

// SetArgs sets the "args" field.
func (m *ActionMutation) SetArgs(s []string) {
	m.args = &s
}

// Args returns the value of the "args" field in the mutation.
func (m *ActionMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *ActionMutation) ResetArgs() {
	m.args = nil
}

// SetOutput sets the "output" field.
func (m *ActionMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *ActionMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldOutput(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *ActionMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[action.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *ActionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[action.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *ActionMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, action.FieldOutput)
}

// SetInstructionID sets the "instruction" edge to the Instruction entity by id.
func (m *ActionMutation) SetInstructionID(id int) {
	m.instruction = &id
}

// ClearInstruction clears the "instruction" edge to the Instruction entity.
func (m *ActionMutation) ClearInstruction() {
	m.clearedinstruction = true
}

// InstructionCleared returns if the "instruction" edge to the Instruction entity was cleared.
func (m *ActionMutation) InstructionCleared() bool {
	return m.clearedinstruction
}

// InstructionID returns the "instruction" edge ID in the mutation.
func (m *ActionMutation) InstructionID() (id int, exists bool) {
	if m.instruction != nil {
		return *m.instruction, true
	}
	return
}

// InstructionIDs returns the "instruction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstructionID instead. It exists only for internal usage by the builders.
func (m *ActionMutation) InstructionIDs() (ids []int) {
	if id := m.instruction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstruction resets all changes to the "instruction" edge.
func (m *ActionMutation) ResetInstruction() {
	m.instruction = nil
	m.clearedinstruction = false
}

// Op returns the operation name.
func (m *ActionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Action).
func (m *ActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.actionType != nil {
		fields = append(fields, action.FieldActionType)
	}
	if m.cmd != nil {
		fields = append(fields, action.FieldCmd)
	}
	if m.args != nil {
		fields = append(fields, action.FieldArgs)
	}
	if m.output != nil {
		fields = append(fields, action.FieldOutput)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case action.FieldActionType:
		return m.ActionType()
	case action.FieldCmd:
		return m.Cmd()
	case action.FieldArgs:
		return m.Args()
	case action.FieldOutput:
		return m.Output()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case action.FieldActionType:
		return m.OldActionType(ctx)
	case action.FieldCmd:
		return m.OldCmd(ctx)
	case action.FieldArgs:
		return m.OldArgs(ctx)
	case action.FieldOutput:
		return m.OldOutput(ctx)
	}
	return nil, fmt.Errorf("unknown Action field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case action.FieldActionType:
		v, ok := value.(action.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case action.FieldCmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmd(v)
		return nil
	case action.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case action.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Action numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(action.FieldOutput) {
		fields = append(fields, action.FieldOutput)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionMutation) ClearField(name string) error {
	switch name {
	case action.FieldOutput:
		m.ClearOutput()
		return nil
	}
	return fmt.Errorf("unknown Action nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionMutation) ResetField(name string) error {
	switch name {
	case action.FieldActionType:
		m.ResetActionType()
		return nil
	case action.FieldCmd:
		m.ResetCmd()
		return nil
	case action.FieldArgs:
		m.ResetArgs()
		return nil
	case action.FieldOutput:
		m.ResetOutput()
		return nil
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instruction != nil {
		edges = append(edges, action.EdgeInstruction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case action.EdgeInstruction:
		if id := m.instruction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinstruction {
		edges = append(edges, action.EdgeInstruction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionMutation) EdgeCleared(name string) bool {
	switch name {
	case action.EdgeInstruction:
		return m.clearedinstruction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionMutation) ClearEdge(name string) error {
	switch name {
	case action.EdgeInstruction:
		m.ClearInstruction()
		return nil
	}
	return fmt.Errorf("unknown Action unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionMutation) ResetEdge(name string) error {
	switch name {
	case action.EdgeInstruction:
		m.ResetInstruction()
		return nil
	}
	return fmt.Errorf("unknown Action edge %s", name)
}

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	uuid               *string
	hostname           *string
	ip                 *string
	port               *string
	pid                *int
	addpid             *int
	clearedFields      map[string]struct{}
	instruction        *int
	clearedinstruction bool
	done               bool
	oldValue           func(context.Context) (*Agent, error)
	predicates         []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id int) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AgentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *AgentMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AgentMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AgentMutation) ResetUUID() {
	m.uuid = nil
}

// SetHostname sets the "hostname" field.
func (m *AgentMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *AgentMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *AgentMutation) ResetHostname() {
	m.hostname = nil
}

// SetIP sets the "ip" field.
func (m *AgentMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AgentMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AgentMutation) ResetIP() {
	m.ip = nil
}

// SetPort sets the "port" field.
func (m *AgentMutation) SetPort(s string) {
	m.port = &s
}

// Port returns the value of the "port" field in the mutation.
func (m *AgentMutation) Port() (r string, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// ResetPort resets all changes to the "port" field.
func (m *AgentMutation) ResetPort() {
	m.port = nil
}

// SetPid sets the "pid" field.
func (m *AgentMutation) SetPid(i int) {
	m.pid = &i
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *AgentMutation) Pid() (r int, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds i to the "pid" field.
func (m *AgentMutation) AddPid(i int) {
	if m.addpid != nil {
		*m.addpid += i
	} else {
		m.addpid = &i
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *AgentMutation) AddedPid() (r int, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *AgentMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
}

// SetInstructionID sets the "instruction" edge to the Instruction entity by id.
func (m *AgentMutation) SetInstructionID(id int) {
	m.instruction = &id
}

// ClearInstruction clears the "instruction" edge to the Instruction entity.
func (m *AgentMutation) ClearInstruction() {
	m.clearedinstruction = true
}

// InstructionCleared returns if the "instruction" edge to the Instruction entity was cleared.
func (m *AgentMutation) InstructionCleared() bool {
	return m.clearedinstruction
}

// InstructionID returns the "instruction" edge ID in the mutation.
func (m *AgentMutation) InstructionID() (id int, exists bool) {
	if m.instruction != nil {
		return *m.instruction, true
	}
	return
}

// InstructionIDs returns the "instruction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstructionID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) InstructionIDs() (ids []int) {
	if id := m.instruction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstruction resets all changes to the "instruction" edge.
func (m *AgentMutation) ResetInstruction() {
	m.instruction = nil
	m.clearedinstruction = false
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uuid != nil {
		fields = append(fields, agent.FieldUUID)
	}
	if m.hostname != nil {
		fields = append(fields, agent.FieldHostname)
	}
	if m.ip != nil {
		fields = append(fields, agent.FieldIP)
	}
	if m.port != nil {
		fields = append(fields, agent.FieldPort)
	}
	if m.pid != nil {
		fields = append(fields, agent.FieldPid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldUUID:
		return m.UUID()
	case agent.FieldHostname:
		return m.Hostname()
	case agent.FieldIP:
		return m.IP()
	case agent.FieldPort:
		return m.Port()
	case agent.FieldPid:
		return m.Pid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldUUID:
		return m.OldUUID(ctx)
	case agent.FieldHostname:
		return m.OldHostname(ctx)
	case agent.FieldIP:
		return m.OldIP(ctx)
	case agent.FieldPort:
		return m.OldPort(ctx)
	case agent.FieldPid:
		return m.OldPid(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case agent.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agent.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case agent.FieldPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case agent.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	var fields []string
	if m.addpid != nil {
		fields = append(fields, agent.FieldPid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldPid:
		return m.AddedPid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agent.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldUUID:
		m.ResetUUID()
		return nil
	case agent.FieldHostname:
		m.ResetHostname()
		return nil
	case agent.FieldIP:
		m.ResetIP()
		return nil
	case agent.FieldPort:
		m.ResetPort()
		return nil
	case agent.FieldPid:
		m.ResetPid()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instruction != nil {
		edges = append(edges, agent.EdgeInstruction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeInstruction:
		if id := m.instruction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinstruction {
		edges = append(edges, agent.EdgeInstruction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeInstruction:
		return m.clearedinstruction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeInstruction:
		m.ClearInstruction()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeInstruction:
		m.ResetInstruction()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// BeaconMutation represents an operation that mutates the Beacon nodes in the graph.
type BeaconMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	sentAt             *time.Time
	receivedAt         *time.Time
	clearedFields      map[string]struct{}
	instruction        *int
	clearedinstruction bool
	done               bool
	oldValue           func(context.Context) (*Beacon, error)
	predicates         []predicate.Beacon
}

var _ ent.Mutation = (*BeaconMutation)(nil)

// beaconOption allows management of the mutation configuration using functional options.
type beaconOption func(*BeaconMutation)

// newBeaconMutation creates new mutation for the Beacon entity.
func newBeaconMutation(c config, op Op, opts ...beaconOption) *BeaconMutation {
	m := &BeaconMutation{
		config:        c,
		op:            op,
		typ:           TypeBeacon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBeaconID sets the ID field of the mutation.
func withBeaconID(id int) beaconOption {
	return func(m *BeaconMutation) {
		var (
			err   error
			once  sync.Once
			value *Beacon
		)
		m.oldValue = func(ctx context.Context) (*Beacon, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Beacon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBeacon sets the old Beacon of the mutation.
func withBeacon(node *Beacon) beaconOption {
	return func(m *BeaconMutation) {
		m.oldValue = func(context.Context) (*Beacon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BeaconMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BeaconMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BeaconMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSentAt sets the "sentAt" field.
func (m *BeaconMutation) SetSentAt(t time.Time) {
	m.sentAt = &t
}

// SentAt returns the value of the "sentAt" field in the mutation.
func (m *BeaconMutation) SentAt() (r time.Time, exists bool) {
	v := m.sentAt
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sentAt" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ResetSentAt resets all changes to the "sentAt" field.
func (m *BeaconMutation) ResetSentAt() {
	m.sentAt = nil
}

// SetReceivedAt sets the "receivedAt" field.
func (m *BeaconMutation) SetReceivedAt(t time.Time) {
	m.receivedAt = &t
}

// ReceivedAt returns the value of the "receivedAt" field in the mutation.
func (m *BeaconMutation) ReceivedAt() (r time.Time, exists bool) {
	v := m.receivedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedAt returns the old "receivedAt" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldReceivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedAt: %w", err)
	}
	return oldValue.ReceivedAt, nil
}

// ClearReceivedAt clears the value of the "receivedAt" field.
func (m *BeaconMutation) ClearReceivedAt() {
	m.receivedAt = nil
	m.clearedFields[beacon.FieldReceivedAt] = struct{}{}
}

// ReceivedAtCleared returns if the "receivedAt" field was cleared in this mutation.
func (m *BeaconMutation) ReceivedAtCleared() bool {
	_, ok := m.clearedFields[beacon.FieldReceivedAt]
	return ok
}

// ResetReceivedAt resets all changes to the "receivedAt" field.
func (m *BeaconMutation) ResetReceivedAt() {
	m.receivedAt = nil
	delete(m.clearedFields, beacon.FieldReceivedAt)
}

// SetInstructionID sets the "instruction" edge to the Instruction entity by id.
func (m *BeaconMutation) SetInstructionID(id int) {
	m.instruction = &id
}

// ClearInstruction clears the "instruction" edge to the Instruction entity.
func (m *BeaconMutation) ClearInstruction() {
	m.clearedinstruction = true
}

// InstructionCleared returns if the "instruction" edge to the Instruction entity was cleared.
func (m *BeaconMutation) InstructionCleared() bool {
	return m.clearedinstruction
}

// InstructionID returns the "instruction" edge ID in the mutation.
func (m *BeaconMutation) InstructionID() (id int, exists bool) {
	if m.instruction != nil {
		return *m.instruction, true
	}
	return
}

// InstructionIDs returns the "instruction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstructionID instead. It exists only for internal usage by the builders.
func (m *BeaconMutation) InstructionIDs() (ids []int) {
	if id := m.instruction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstruction resets all changes to the "instruction" edge.
func (m *BeaconMutation) ResetInstruction() {
	m.instruction = nil
	m.clearedinstruction = false
}

// Op returns the operation name.
func (m *BeaconMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Beacon).
func (m *BeaconMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BeaconMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.sentAt != nil {
		fields = append(fields, beacon.FieldSentAt)
	}
	if m.receivedAt != nil {
		fields = append(fields, beacon.FieldReceivedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BeaconMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case beacon.FieldSentAt:
		return m.SentAt()
	case beacon.FieldReceivedAt:
		return m.ReceivedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BeaconMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case beacon.FieldSentAt:
		return m.OldSentAt(ctx)
	case beacon.FieldReceivedAt:
		return m.OldReceivedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Beacon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BeaconMutation) SetField(name string, value ent.Value) error {
	switch name {
	case beacon.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case beacon.FieldReceivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Beacon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BeaconMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BeaconMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BeaconMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Beacon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BeaconMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(beacon.FieldReceivedAt) {
		fields = append(fields, beacon.FieldReceivedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BeaconMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BeaconMutation) ClearField(name string) error {
	switch name {
	case beacon.FieldReceivedAt:
		m.ClearReceivedAt()
		return nil
	}
	return fmt.Errorf("unknown Beacon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BeaconMutation) ResetField(name string) error {
	switch name {
	case beacon.FieldSentAt:
		m.ResetSentAt()
		return nil
	case beacon.FieldReceivedAt:
		m.ResetReceivedAt()
		return nil
	}
	return fmt.Errorf("unknown Beacon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BeaconMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instruction != nil {
		edges = append(edges, beacon.EdgeInstruction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BeaconMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case beacon.EdgeInstruction:
		if id := m.instruction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BeaconMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BeaconMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BeaconMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinstruction {
		edges = append(edges, beacon.EdgeInstruction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BeaconMutation) EdgeCleared(name string) bool {
	switch name {
	case beacon.EdgeInstruction:
		return m.clearedinstruction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BeaconMutation) ClearEdge(name string) error {
	switch name {
	case beacon.EdgeInstruction:
		m.ClearInstruction()
		return nil
	}
	return fmt.Errorf("unknown Beacon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BeaconMutation) ResetEdge(name string) error {
	switch name {
	case beacon.EdgeInstruction:
		m.ResetInstruction()
		return nil
	}
	return fmt.Errorf("unknown Beacon edge %s", name)
}

// InstructionMutation represents an operation that mutates the Instruction nodes in the graph.
type InstructionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	sentAt        *time.Time
	clearedFields map[string]struct{}
	agent         *int
	clearedagent  bool
	action        *int
	clearedaction bool
	beacon        *int
	clearedbeacon bool
	done          bool
	oldValue      func(context.Context) (*Instruction, error)
	predicates    []predicate.Instruction
}

var _ ent.Mutation = (*InstructionMutation)(nil)

// instructionOption allows management of the mutation configuration using functional options.
type instructionOption func(*InstructionMutation)

// newInstructionMutation creates new mutation for the Instruction entity.
func newInstructionMutation(c config, op Op, opts ...instructionOption) *InstructionMutation {
	m := &InstructionMutation{
		config:        c,
		op:            op,
		typ:           TypeInstruction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstructionID sets the ID field of the mutation.
func withInstructionID(id int) instructionOption {
	return func(m *InstructionMutation) {
		var (
			err   error
			once  sync.Once
			value *Instruction
		)
		m.oldValue = func(ctx context.Context) (*Instruction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Instruction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstruction sets the old Instruction of the mutation.
func withInstruction(node *Instruction) instructionOption {
	return func(m *InstructionMutation) {
		m.oldValue = func(context.Context) (*Instruction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstructionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstructionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *InstructionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSentAt sets the "sentAt" field.
func (m *InstructionMutation) SetSentAt(t time.Time) {
	m.sentAt = &t
}

// SentAt returns the value of the "sentAt" field in the mutation.
func (m *InstructionMutation) SentAt() (r time.Time, exists bool) {
	v := m.sentAt
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sentAt" field's value of the Instruction entity.
// If the Instruction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstructionMutation) OldSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ResetSentAt resets all changes to the "sentAt" field.
func (m *InstructionMutation) ResetSentAt() {
	m.sentAt = nil
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *InstructionMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *InstructionMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared returns if the "agent" edge to the Agent entity was cleared.
func (m *InstructionMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *InstructionMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *InstructionMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *InstructionMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetActionID sets the "action" edge to the Action entity by id.
func (m *InstructionMutation) SetActionID(id int) {
	m.action = &id
}

// ClearAction clears the "action" edge to the Action entity.
func (m *InstructionMutation) ClearAction() {
	m.clearedaction = true
}

// ActionCleared returns if the "action" edge to the Action entity was cleared.
func (m *InstructionMutation) ActionCleared() bool {
	return m.clearedaction
}

// ActionID returns the "action" edge ID in the mutation.
func (m *InstructionMutation) ActionID() (id int, exists bool) {
	if m.action != nil {
		return *m.action, true
	}
	return
}

// ActionIDs returns the "action" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionID instead. It exists only for internal usage by the builders.
func (m *InstructionMutation) ActionIDs() (ids []int) {
	if id := m.action; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAction resets all changes to the "action" edge.
func (m *InstructionMutation) ResetAction() {
	m.action = nil
	m.clearedaction = false
}

// SetBeaconID sets the "beacon" edge to the Beacon entity by id.
func (m *InstructionMutation) SetBeaconID(id int) {
	m.beacon = &id
}

// ClearBeacon clears the "beacon" edge to the Beacon entity.
func (m *InstructionMutation) ClearBeacon() {
	m.clearedbeacon = true
}

// BeaconCleared returns if the "beacon" edge to the Beacon entity was cleared.
func (m *InstructionMutation) BeaconCleared() bool {
	return m.clearedbeacon
}

// BeaconID returns the "beacon" edge ID in the mutation.
func (m *InstructionMutation) BeaconID() (id int, exists bool) {
	if m.beacon != nil {
		return *m.beacon, true
	}
	return
}

// BeaconIDs returns the "beacon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BeaconID instead. It exists only for internal usage by the builders.
func (m *InstructionMutation) BeaconIDs() (ids []int) {
	if id := m.beacon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBeacon resets all changes to the "beacon" edge.
func (m *InstructionMutation) ResetBeacon() {
	m.beacon = nil
	m.clearedbeacon = false
}

// Op returns the operation name.
func (m *InstructionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Instruction).
func (m *InstructionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstructionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.sentAt != nil {
		fields = append(fields, instruction.FieldSentAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstructionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instruction.FieldSentAt:
		return m.SentAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstructionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instruction.FieldSentAt:
		return m.OldSentAt(ctx)
	}
	return nil, fmt.Errorf("unknown Instruction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstructionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instruction.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	}
	return fmt.Errorf("unknown Instruction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstructionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstructionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstructionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Instruction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstructionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstructionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstructionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Instruction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstructionMutation) ResetField(name string) error {
	switch name {
	case instruction.FieldSentAt:
		m.ResetSentAt()
		return nil
	}
	return fmt.Errorf("unknown Instruction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstructionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.agent != nil {
		edges = append(edges, instruction.EdgeAgent)
	}
	if m.action != nil {
		edges = append(edges, instruction.EdgeAction)
	}
	if m.beacon != nil {
		edges = append(edges, instruction.EdgeBeacon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstructionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instruction.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case instruction.EdgeAction:
		if id := m.action; id != nil {
			return []ent.Value{*id}
		}
	case instruction.EdgeBeacon:
		if id := m.beacon; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstructionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstructionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstructionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedagent {
		edges = append(edges, instruction.EdgeAgent)
	}
	if m.clearedaction {
		edges = append(edges, instruction.EdgeAction)
	}
	if m.clearedbeacon {
		edges = append(edges, instruction.EdgeBeacon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstructionMutation) EdgeCleared(name string) bool {
	switch name {
	case instruction.EdgeAgent:
		return m.clearedagent
	case instruction.EdgeAction:
		return m.clearedaction
	case instruction.EdgeBeacon:
		return m.clearedbeacon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstructionMutation) ClearEdge(name string) error {
	switch name {
	case instruction.EdgeAgent:
		m.ClearAgent()
		return nil
	case instruction.EdgeAction:
		m.ClearAction()
		return nil
	case instruction.EdgeBeacon:
		m.ClearBeacon()
		return nil
	}
	return fmt.Errorf("unknown Instruction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstructionMutation) ResetEdge(name string) error {
	switch name {
	case instruction.EdgeAgent:
		m.ResetAgent()
		return nil
	case instruction.EdgeAction:
		m.ResetAction()
		return nil
	case instruction.EdgeBeacon:
		m.ResetBeacon()
		return nil
	}
	return fmt.Errorf("unknown Instruction edge %s", name)
}
